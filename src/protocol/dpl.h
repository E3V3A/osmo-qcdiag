#pragma once

enum diag_dpl_cmd_type {
	DIAG_DPL_RESET_LOGGING		= 1,
	DIAG_DPL_GET_SUPPORTED_IFACES	= 2,
	DIAG_DPL_GET_IFACE_DESC		= 3,
	DIAG_DPL_SET_IFACE_LOGGING	= 4,
	DIAG_DPL_GET_SUPPORTED_PROTOCOLS= 5,
};

enum diag_dpl_prot_net_type {
	DIAG_DPL_IID_PROT_NET_IP	= 1,
	DIAG_DPL_IID_PROT_NET_HDLC_UNFR	= 2,
};

enum diag_dpl_prot_link_type {
	DIAG_DPL_IID_PROT_LINK_ANY	= 0,
	DIAG_DPL_IID_PROT_LINK_ETHER	= 1,
	DIAG_DPL_IID_PROT_LINK_PPP_HDLC1= 2,
	DIAG_DPL_IID_PROT_LINK_ROHC_IP	= 3,
	DIAG_DPL_IID_PROT_LINK_IPHC_IP	= 4,
};

/* If set, IID refers to flow based filter? */
#define DIAG_DPL_IID_FLAG_FLOW		0x20
/* If set, IID refers to TX; unset: RX */
#define DIAG_DPL_IID_FLAG_DIR_TX	0x40
/* If set, IID refers to link; unset: network */
#define DIAG_DPL_IID_FLAG_LINK		0x80

/* network based logging: legacy */

struct dpl_iid {
	uint8_t flags; /* see above */
	uint8_t if_name; /* 0..99 */
	uint8_t protocol;  /* diag_dpl_prot_{link,net}_type */
	uint8_t link_instance;
} __attribute__ ((packed));

/* DIAG_DPL_GET_SUPPORTED_IFACES */
/* request: regulsr diapkt_subsys_hdr */
struct dpl_get_sup_if_resp {
	uint8_t num_ifaces;
	uint8_t iface_id[0];
};

/* DIAG_DPL_GET_IFACE_DESC */
struct dpl_get_if_desc_req {
	uint8_t iface_id;
};
/*
struct dpl_get_if_desc_resp {
	uint8_t iface_id;
	null-terminated interface description
	uint8_t num_links;
	array of null-terminated strings
	uint8_t num_flows
	array of null-terminated flows
};
*/

/* DIAG_DPL_SET_IFACE_LOGGING */
struct dpl_set_if_log_req {
	uint8_t iface_id;
	uint8_t num_log_flags;
	struct {
		uint32_t iid;
		uint32_t link_type;
	} log_flags[0];
};

/* header pre-fixed to actual packet payload; as generated by
 * DPLI_BUILD_LOG_PACKET inside the modem */
struct dpl_hdr {
	struct dpl_iid iid;
	uint16_t seq_nr;
	uint16_t seg_num;
	uint8_t data[0];
} __attribute__ ((packed));
